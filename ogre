#!/usr/bin/env python3

"""
ogre : port scanner and brute-force tool
Copyright (C) 2014 Tristan Fisher

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


import mimetypes
import paramiko
import socket
import tempfile
import gzip
import signal
import sys


VERSION = 0.03
TEMP_DIR = tempfile.gettempdir()


def _sig_handler(_signal, _frame):
    sys.exit(0)

signal.signal(signal.SIGINT, _sig_handler)  # ^c shouldn't spit out a stacktrace


def send_packet(host, port, timeout_seconds, recv_bytes):
    """send a tcp packet with a binary space as content to generate a response
    from the listening protocol.  returns a tuple of (status, host, port, recv_bytes data)

    arguments:
    host -- target host
    port -- target port
    timeout_seconds -- how long to wait for a response
    recv_bytes -- number of bytes to place in the tuple return

    note:
    [Errno 61] Connection refused => probably nothing listening

    Listening will log something like:
        SSH => "Did not receive identification string"
        HTTP => 400

    If this is a problem, open a pull req with better handling per protocol.
    """
    try:
        _s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        _s.setblocking(1)
        _s.settimeout(timeout_seconds)
        _s.connect((host, port))
        _s.sendall(b" ")  # send something to try to prompt a response
        return 1, host, port, _s.recv(recv_bytes)
    except Exception as e:
        return 0, host, port, e


def iterate_over_password_file(password_file):

    # open = gzip.open would confuse interpreter
    _open = open

    if "gzip" in mimetypes.guess_type(password_file):
        _open = gzip.open

    with _open(password_file, "rb") as pass_dict:
        for line in pass_dict:
            yield line


def ssh(host, port, username, password=None, timeout=5):
    """Returns a tuple with the result of trying to SSH to an endpoint.

    arguments:
    host -- target host
    port -- target port
    username -- username for authentication
    password -- password for authentication
    timeout -- how long to wait for a response on SSH build-up and banner response
    """
    KEYS_FILENAME = TEMP_DIR + "/ogre.keys"
    LOG_FILENAME = TEMP_DIR + "/ogre.ssh.log"

    try:
        client = paramiko.SSHClient()
        paramiko.util.log_to_file(LOG_FILENAME)
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        try:
            client.connect(hostname=host, port=port, username=username, password=password,
                       timeout=timeout, banner_timeout=timeout, look_for_keys=False,
                       key_filename=KEYS_FILENAME)
            try:
                stdin, stdout, stderr = client.exec_command("id")
                for _s in [stdout, stderr]:
                    #_s.readlines() for ChannelFile
                    _s = list(_s)
                    if len(_s) > 0:
                        return 1, host, port, _s
                client.close()
            except socket.error as e:
                return 0, host, port, "socket was closed on us"
        except socket.error as e:
            return 0, host, port, "[socket.error] {host} : {error}".format(host=host, error=e)
        except paramiko.SSHException as pm_ssh:
            return 0, host, port, "[paramiko.SSHException] : {0}".format(pm_ssh)
        except Exception as e:
            return 0, host, port, e

    except:  # don't crash out, we might be in a loop to check N hosts
        return 0, host, port, "[exception] fatal error occurred before creating connection"


def filter_response(_resp, show_failures=False):
    """Return a tuple that optionally filters failure responses.
    arguments:
    _resp -- the response tuple to evaluate

    Keyword arguments:
    show_failures -- Boolean as to whether or not to return failure responses
    """
    if show_failures:
        return _resp
    elif _resp[0] == 1:
        return _resp


def scan(settings_dict):
    if settings_dict["debug"]:
        print("DEBUG >> " + str(settings_dict))

    for _port in settings_dict["ports"]:
        _f = filter_response(send_packet(settings_dict["host"], int(_port), settings_dict["timeout"],
                                    settings_dict["scan_receive_bytes"]), settings_dict["show_failures"])
        if _f: yield _f

def crack(settings_dict):
    """yield a response of trying a username/password combination against a host/port combination.

    arguments:
    settings_dict -- a dictionary containing at least:
        - host -- target host
        - port -- target port
        - username -- username for authentication

        and one of:
        - password -- password for authentication
        - password_file -- gzip or plaintext file to iterate over for authentication passwords

        and optionally:
        - timeout -- how long to wait for a response on SSH build-up and banner response
        - show_failures -- whether or not to ask filter_response() to return failures

    """

    # todo: ehhhh kind of breaks modular expectation. raise err and catch in argparse section?
    if not (settings_dict["password"] or settings_dict["password_file"]):
        parser.error("--crack specified, but neither --password or --password_file was set.")
    if (settings_dict["password"] and settings_dict["password_file"]):
        parser.error("please specify --password OR --password_file (not both).")

    # TODO: DRY up -- potentially iterate on _password
    # TODO: add iterator over username dict

    if settings_dict["debug"]:
        print("DEBUG >> " + str(settings_dict))

    _username = settings_dict["username"]

    if settings_dict["password"]:
        for _port in settings_dict["ports"]:
            _f = filter_response(ssh(host=settings_dict["host"], port=int(_port),
                username=_username, password=settings_dict["password"],
                timeout=settings_dict["timeout"]), settings_dict["show_failures"])
            if _f: yield _f

    else:
        for _port in settings_dict["ports"]:
            # Don't store all passwords in memory, password file may be large
            password_iterable = iterate_over_password_file(settings_dict["password_file"])

            for _pass in password_iterable:

                _pass = _pass.rstrip() #remove whatever separates lines
                _resp = ssh(host=settings_dict["host"], port=int(_port),
                    username=_username, password=_pass, timeout=settings_dict["timeout"]) + (_username, _pass)
                _f = filter_response(_resp, settings_dict["show_failures"])
                if _f: yield _f
                if _resp[0] == 1:
                    if settings_dict['stop_on_success']:
                        break

            #Don't stop iteration here; we're in the port loop.
        #password_iterable.send(StopIteration)


if __name__ == "__main__":

    import argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
                                     description="Ogre {ver} \n"
                                                 "Scan ports and/or brute-force logins.\n"
                                                 "Written by Tristan Fisher (http://tristanfisher.com)"
                                                 .format(ver=VERSION))

    actions = parser.add_argument_group("actions", "at least one of the following actions is required:")
    actions.add_argument("--scan", action="store_true", help="scan port for a tcp response.")
    actions.add_argument("--crack", action="store_true", help="attempt to crack the SSH password on a server")

    parser.add_argument("--version", action="version", version="%(prog)s {0}".format(VERSION))
    parser.add_argument("--verbose", "--v", action="store_true", default=False, help="vebose output")
    parser.add_argument("--host", "--ip", dest="host", type=str, required=True, help="target host")
    parser.add_argument("--port", "--ports", "--p", dest="ports", nargs="*",
                        default="22", help="ports list (defaults to 22)") # don"t enforce type (22-2222)
    parser.add_argument("--scan_receive_bytes", "--scv", type=int, default="2048",
                        help="number (int) of bytes to receive when opening raw sockets to hosts (defaults to 2048)")
    parser.add_argument("--timeout", "--t",  metavar="TIMEOUT SECONDS",
                        type=float, default=5.0, help="time you are willing to wait per host")
    parser.add_argument("--log_file", "--l",  metavar="/PATH/TO/LOGFILE",
                        type=str, default=TEMP_DIR+"/ogre.txt",
                        help="path to logfile to use.  defaults to $TMPDIR/ogre.txt")
    parser.add_argument("--debug", "--d", action="store_true", default=False, help="get debugging information")
    parser.add_argument("--show_failures", "--failures", action="store_true", default=False,
                        help="display closed/refused connections to ports in the output")

    # TODO: username file? for u in username_file (fork): for p in password (fork)
    options_ssh = parser.add_argument_group("ssh", "options for trying to get a shell via ssh")
    options_ssh.add_argument("--username", "--u", type=str, default="root", help="specify username (defaults to root)")

    #password_option = options_ssh.add_mutually_exclusive_group(required=True) -- this becomes a pain if scan only
    options_ssh.add_argument("--password", "--pw",  metavar="PASSWORD",
                             type=str, help="if you know the password, specify it, else, use --password_file")
    options_ssh.add_argument("--password_file", "--f", metavar="PASSWORD_FILE_NAME",
                             type=str, help="specify a password file, newline separated")
    options_ssh.add_argument("--stop_on_success", action="store_false", default=True,
                        help="stop trying to get a shell when successful (useful when trying multiple usernames")

    args = parser.parse_args()

    if len(sys.argv) < 2:
        parser.print_help()

    if args.ports:
        if ("-" in args.ports[0]) and ("," in args.ports[0]):
            raise NotImplementedError("comma separated and ranges not supported yet")
        elif "-" in args.ports[0]:
            args.ports = [int(s) for s in args.ports[0].split("-")]
            args.ports[-1] += 1  # handle off by one-error
            args.ports = range(args.ports[0], args.ports[-1])
        elif "," in args.ports[0]:
            args.ports = args.ports[0].split(",")

    # evaluate this only when we"'re done modifying args.
    argument_dictionary = vars(args)

    if args.scan and args.crack:
        for _s in scan(argument_dictionary):
            _port = (_s[2])
            _resp_text = (_s[3])
            # shameful, but works for now. should get more raw data from socket for fingerprint
            _proto = 'ssh' if 'ssh' in str(_resp_text).lower() else None
            if _proto == 'ssh':
                argument_dictionary["ports"] = [_port]
                for _conn in crack(argument_dictionary):
                    print(_conn)
            else:
                print(_s)

        sys.exit(0)  # don't flow through to other actions
    elif args.scan:
        for _s in scan(argument_dictionary):
            print(_s)
    elif args.crack:
        for _p in crack(argument_dictionary):
            print(_p)

    else:
        parser.error("No action specified.  Re-run with scan or crack.")